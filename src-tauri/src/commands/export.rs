use tauri::State;
use crate::DatabaseState;
use std::fs;
use std::path::Path;

#[tauri::command]
pub fn read_file_content(file_path: String) -> Result<String, String> {
    println!("Reading file: {}", file_path);
    match fs::read_to_string(&file_path) {
        Ok(content) => {
            println!("Successfully read {} bytes", content.len());
            Ok(content)
        },
        Err(e) => {
            let error_msg = format!("Failed to read file '{}': {}", file_path, e);
            eprintln!("{}", error_msg);
            Err(error_msg)
        }
    }
}

#[tauri::command]
pub fn write_file_content(file_path: String, content: String) -> Result<String, String> {
    println!("Writing file: {}", file_path);
    match fs::write(&file_path, content) {
        Ok(_) => {
            println!("Successfully wrote to file");
            Ok("File saved successfully".to_string())
        },
        Err(e) => {
            let error_msg = format!("Failed to write file '{}': {}", file_path, e);
            eprintln!("{}", error_msg);
            Err(error_msg)
        }
    }
}

#[derive(serde::Serialize, serde::Deserialize)]
pub struct ExportEnvRequest {
    pub environment_id: i64,
}

#[derive(serde::Serialize)]
pub struct ExportEnvResponse {
    pub success: bool,
    pub content: Option<String>,
    pub message: String,
}

#[derive(serde::Serialize, serde::Deserialize)]
pub struct ImportEnvRequest {
    pub environment_id: i64,
    pub content: String,
}

#[derive(serde::Serialize)]
pub struct ImportEnvResponse {
    pub success: bool,
    pub imported_count: usize,
    pub errors: Option<Vec<String>>,
    pub message: String,
}

#[tauri::command]
pub fn export_env(
    request: ExportEnvRequest,
    state: State<DatabaseState>,
) -> Result<ExportEnvResponse, String> {
    let db_guard = state.db.lock().map_err(|e| e.to_string())?;
    let db = db_guard.as_ref().ok_or("Database not initialized")?;
    
    let key_guard = state.encryption_key.lock().map_err(|e| e.to_string())?;
    let key = key_guard.as_ref().ok_or("Encryption key not available")?;

    // Get all variables for this environment (decrypted)
    let variables = crate::database::operations::variables::get_variables_by_environment_decrypted(
        db.connection(),
        request.environment_id,
        key,
    ).map_err(|e| e.to_string())?;

    // Store count before consuming vector
    let var_count = variables.len();

    // Generate .env format
    let mut content = String::new();
    content.push_str("# Generated by Clerk - Secure Environment Manager\n");
    content.push_str(&format!("# Environment ID: {}\n", request.environment_id));
    content.push_str(&format!("# Total variables: {}\n", var_count));
    content.push_str("# WARNING: This file contains sensitive data. Keep it secure!\n\n");

    for variable in variables {
        // Escape value if it contains special characters
        let value = if variable.value.contains(' ') || variable.value.contains('"') {
            format!("\"{}\"", variable.value.replace('"', "\\\""))
        } else {
            variable.value.clone()
        };
        
        content.push_str(&format!("{}={}\n", variable.key, value));
    }

    Ok(ExportEnvResponse {
        success: true,
        content: Some(content),
        message: format!("Exported {} variables", var_count),
    })
}

#[tauri::command]
pub fn import_env(
    request: ImportEnvRequest,
    state: State<DatabaseState>,
) -> Result<ImportEnvResponse, String> {
    let db_guard = state.db.lock().map_err(|e| e.to_string())?;
    let db = db_guard.as_ref().ok_or("Database not initialized")?;
    
    let key_guard = state.encryption_key.lock().map_err(|e| e.to_string())?;
    let key = key_guard.as_ref().ok_or("Encryption key not available")?;

    let mut imported_count = 0;
    let mut errors = Vec::new();

    // Parse .env content
    for (line_num, line) in request.content.lines().enumerate() {
        let line = line.trim();
        
        // Skip empty lines and comments
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        // Parse KEY=VALUE format
        if let Some(eq_pos) = line.find('=') {
            let key_str = line[..eq_pos].trim();
            let value_str = line[eq_pos + 1..].trim();

            // Remove quotes and unescape if present
            let final_value = if value_str.starts_with('"') && value_str.ends_with('"') && value_str.len() >= 2 {
                let unquoted = &value_str[1..value_str.len() - 1];
                unquoted.replace("\\\"", "\"")
            } else {
                value_str.to_string()
            };

            if key_str.is_empty() {
                errors.push(format!("Line {}: Empty key", line_num + 1));
                continue;
            }

            // Create or update variable
            match crate::database::operations::variables::create_variable_encrypted(
                db.connection(),
                request.environment_id,
                key_str.to_string(),
                final_value.clone(),
                None,
                key,
            ) {
                Ok(_) => imported_count += 1,
                Err(_) => {
                    // If variable exists, try to update it
                    if let Ok(existing_vars) = crate::database::operations::variables::get_variables_by_environment_decrypted(
                        db.connection(),
                        request.environment_id,
                        key,
                    ) {
                        if let Some(existing) = existing_vars.iter().find(|v| v.key == key_str) {
                            if crate::database::operations::variables::update_variable_encrypted(
                                db.connection(),
                                existing.id,
                                key_str.to_string(),
                                final_value,
                                None,
                                key,
                            ).is_ok() {
                                imported_count += 1;
                                continue;
                            }
                        }
                    }
                    errors.push(format!("Line {}: Failed to import {}", line_num + 1, key_str));
                }
            }
        } else {
            errors.push(format!("Line {}: Invalid format (missing '=')", line_num + 1));
        }
    }

    let message = if errors.is_empty() {
        format!("Successfully imported {} variables", imported_count)
    } else {
        format!(
            "Imported {} variables with {} errors: {}",
            imported_count,
            errors.len(),
            errors.join(", ")
        )
    };

    Ok(ImportEnvResponse {
        success: true,
        imported_count,
        errors: if errors.is_empty() { None } else { Some(errors) },
        message,
    })
}

#[tauri::command]
pub fn export_env_to_file(
    request: ExportEnvRequest,
    file_path: String,
    state: State<DatabaseState>,
) -> Result<String, String> {
    let db_guard = state.db.lock().map_err(|e| e.to_string())?;
    let db = db_guard.as_ref().ok_or("Database not initialized")?;
    
    let key_guard = state.encryption_key.lock().map_err(|e| e.to_string())?;
    let key = key_guard.as_ref().ok_or("Encryption key not available")?;

    // Get all variables for this environment (decrypted)
    let variables = crate::database::operations::variables::get_variables_by_environment_decrypted(
        db.connection(),
        request.environment_id,
        key,
    ).map_err(|e| e.to_string())?;

    // Store count before consuming vector
    let var_count = variables.len();

    // Generate .env format
    let mut content = String::new();
    content.push_str("# Generated by Clerk - Secure Environment Manager\n");
    content.push_str(&format!("# Environment ID: {}\n", request.environment_id));
    content.push_str(&format!("# Total variables: {}\n", var_count));
    content.push_str("# WARNING: This file contains sensitive data. Keep it secure!\n\n");

    for variable in variables {
        // Escape value if it contains special characters
        let value = if variable.value.contains(' ') || variable.value.contains('"') {
            format!("\"{}\"", variable.value.replace('"', "\\\""))
        } else {
            variable.value.clone()
        };
        
        content.push_str(&format!("{}={}\n", variable.key, value));
    }

    // Write to file
    let path = Path::new(&file_path);
    fs::write(path, content)
        .map_err(|e| format!("Failed to write file: {}", e))?;

    Ok(format!("Exported {} variables to {}", var_count, file_path))
}
